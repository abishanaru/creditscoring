---
title: "Credit Scoring SBD2"
author: "Abishan Arumugavel, Vladyslav Gorbunov, Gilles Nikles, Josua Reich"
date: "2023-10-10"
output: html_document
---

In the rapidly evolving landscape of financial technology, credit scoring remains a cornerstone in determining the creditworthiness of applicants. This paper delves into the realm of predictive modeling, using a dataset provided by our professors, enriched with comprehensive credit scoring information. The overarching objective of our study is to train a model that efficiently and accurately determines the eligibility of individuals for credit approval.

The task set forth by our professors involves a comprehensive journey through four key exercises. The first exercise is centered around a thorough analysis of the dataset. Here, we delve into understanding the underlying structures, identifying critical variables, and most importantly, balancing the dataset to ensure a fair representation of diverse credit scenarios.

Subsequently, in the second exercise, we focus on training and testing a logistic classifier. This step is crucial in establishing a baseline model from which further improvements can be measured.

The third exercise involves enhancing the predictive performance of the model. This stage is particularly challenging and significant, as it entails fine-tuning the model to ensure it captures the nuances of credit scoring with greater accuracy and efficiency.

Finally, the fourth exercise invites us to step into the practical world. Here, we explore the various challenges a company may face if they were to implement our model in a real-world scenario. This exercise not only grounds our theoretical work in reality but also provides valuable insights into the practical implications and considerations in deploying machine learning models in the credit industry.

This paper aims to not only present a robust model for credit scoring but also to contribute to the broader understanding of how machine learning can be effectively utilized in financial decision-making processes.


## Load packages and data

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Set seed for reproducibility
set.seed(7)

libraries = c("readr", "tidyverse", "ggplot2", "dplyr", "reshape2", "plotly", "caret", "DescTools", "pROC", "ROCR", "ROSE", "Boruta", "RColorBrewer", "ggcorrplot", "PerformanceAnalytics", "corrr", "networkD3", "reshape", "knitr", "dlookr", "corrplot")

lapply(libraries, function(x) if (!(x %in% installed.packages())) {
  install.packages(x)
})

lapply(libraries, library, quietly = TRUE, character.only = TRUE)

rm(list=ls())

# Import of dataset
loan_sample <- read_csv("loan_sample_8.csv")

# Create a copy of the original dataset
loan_sample_original <- loan_sample
```


## Excercise 1

### 1.1 Describe the data. Specifically:

#### 1.1.1: Check and report the structure of the data set.
```{r}
str(loan_sample)
```

```{r}
# Checking for NAs
any(is.na(loan_sample))
```
The result of "FALSE" from the check indicates that there are no missing values (NAs) in the "loan_sample" dataset.


#### 1.1.2: How many numeric and how many categorical variables are included in the data? What categorical variable has the most levels in it?
```{r}
# First we have to check whether all variables have been imported in the correct format. 
first_overview <- overview(loan_sample)
plot(first_overview)
```
It is clearly visible that the columns with the data type character still have to be converted to factors. In addition, the "Status" column is currently still a numeric data type. This must also be converted to factor, as it is a binary variable. 

```{r}
loan_sample <- loan_sample %>%
  mutate_if(is.character, as.factor) %>% # Convert all character columns to factors
  mutate(Status = as.factor(Status)) # Convert 'Status' column to factor

# Plot to see, if the datatypes are correct
second_overview <- overview(loan_sample)
plot(second_overview)
```
That looks right, now we can count the number of variables.

```{r}
# Count numeric variables in 'loan_sample'
numeric_vars_count <- sum(sapply(loan_sample, is.numeric))

# Count categorical (factor) variables in 'loan_sample'
categorical_vars_count <- sum(sapply(loan_sample, is.factor))

# Print counts of numeric and categorical variables
cat("There are", numeric_vars_count, "numeric variables and", categorical_vars_count, "categorical variables in the dataset.")

```

```{r}
categorical_levels <- sapply(loan_sample, function(x) if(is.factor(x)) length(unique(x)) else NA)

# Find the name of the categorical variable with the most levels
cat_var_most_levels <- names(which.max(categorical_levels))

# Find the number of levels for this variable
levels_count <- max(categorical_levels, na.rm = TRUE)

# Print the variable name and the number of levels
cat("The categorical variable with the most levels in the dataset is:", cat_var_most_levels, "with", levels_count, "levels.")
```

#### 1.1.3: Summarize the variables. Discuss the summary statistics obtained.
```{r}
# Categorial Label with the most Levels
summary(loan_sample)
```
Our loan data includes information on 40,000 loans. The average loan size is about $11,687, but this number can be as low as $1,000 or as high as $40,000, showing that loan amounts are different for different people. The average interest rate on a loan is 12.62%, but some people get lower rates like 5.31%, and others get higher rates up to 27.49%. This shows there are many different interest rates that people are getting. People who have taken out loans make an average of $63,400 a year, but there is a big difference in how much money people make. Some make more, and some make less. The debt-to-income ratio (DTI) tells us how much debt people have compared to their income. On average, this number is 18.22% for the loans we looked at. Looking at how many credit lines people have open, the average is 10, but in total, they might have had up to 21 over time. This tells us about how many loans or credit cards people might be using or have used before. The average amount people owe on their credit lines is $11,995, and they use about half of the credit available to them. This tells us about how much of their available loan money they are using. People also pay about $1,818 in interest on average. This is extra money they pay in addition to the loan they took out. When we look at all the loans and credit people have, the total amount they owe on average is $99,100. This shows that people have a lot of loans or owe a lot of money on their credit lines. Finally, the average limit people have on their credit lines is $24,194. This is how much the bank or loan company lets them borrow in total.

#### 1.1.4: Check the levels of the target variable by choosing the appropriate visualization. Is the target variable balanced?
```{r}
# Plot the distribution of the target variable
ggplot(loan_sample, aes(x = Status, fill = Status)) + 
  geom_bar() +
  scale_fill_brewer(palette = "Set1") + 
  labs(title = 'Distribution of target variable (Status)', x = 'Status', y = 'Count') +
  theme_minimal()

```
The target variable 'Status' in our dataset distinctly categorizes credit approval outcomes into two levels: '0' represents a 'No', indicating that the credit has not been approved, whereas '1' signifies a 'Yes', confirming the approval of the credit.

The target variable in our dataset shows a significant imbalance, with a substantially higher number of credits not being approved. This imbalance is important to address because, in machine learning, an unbalanced dataset can lead to biased models that over-predict the majority class, in this case, the non-approved credits. Consequently, balancing the dataset is crucial for training an accurate and reliable logistic classifier that fairly represents both outcomes. 

1.1.5: Check the distribution of the numeric variables in the data set (include different visual representations).
```{r}
# Histograms
loan_sample %>% 
  select_if(is.numeric) %>% 
  gather(key = "variable", value = "value") %>%
  ggplot(aes(x = value)) +
  geom_histogram(bins = 30) +
  facet_wrap(~variable, scales = 'free_x') +
  theme_minimal()
```

The histogram we created for the variable open_acc has gaps. We should examine this more closely.
```{r}
# Create boxplot of the variable total_acc
ggplot(loan_sample, aes(x = open_acc)) +
  geom_histogram(bins = 22) + # Adjust the number of bins as necessary
  labs(x = "Open Accounts", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```
Since the variable ranges from 1 to 22, using 30 bins leads to empty spaces. Adjusting the bins to match the actual value range has provided a clearer, gap-free histogram.

```{r}
# Boxplots
loan_sample %>% 
  select_if(is.numeric) %>% 
  gather(key = "variable", value = "value") %>%
  ggplot(aes(y = value)) +
  geom_boxplot() +
  facet_wrap(~variable, scales = 'free') +
  theme_minimal()
```


### 1.2: Investigating outliers with a box plot
Elaborate your view on how to proceed in dealing with the outliers and – if necessary – take appropriate action.
```{r}
# Reshape the data to long format and scale the numeric values
loan_sample_long_scaled <- loan_sample %>%
  select(where(is.numeric)) %>%
  mutate(across(everything(), scale)) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value")

# Create a boxplot with the scaled values
ggplot(loan_sample_long_scaled, aes(x = variable, y = value)) +
  geom_boxplot() +
  labs(x = "", y = "Scaled Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

The box plot illustrated the the distribution of scaled numeric variables. Outliers are visible as individual points outside the box plot. It is visible that most of the variables have some outliers.

When considering how to deal with outliers, it is important to understand their nature and the potential impact on the analysis. If outliers represent errors or anomalies that are not characteristic of the population, they can be removed or corrected. 


```{r}
# Visualizing all variables with and without the outliers
loan_sample %>%
  plot_outlier(diagnose_outlier(loan_sample) %>%
                 filter(outliers_ratio >= 1.5) %>%
                 select(variables) %>%
                 unlist())

```

```{r}
# Function to check if a variable should be truncated
should_keep <- function(x, lower_perc, upper_perc) {
  lower_bound <- quantile(x, lower_perc, na.rm = TRUE)
  upper_bound <- quantile(x, upper_perc, na.rm = TRUE)
  x >= lower_bound & x <= upper_bound
}
# Apply truncation and keep rows where all numeric variables are within the specified range
loan_sample_truncated <- loan_sample %>%
  filter(if_all(where(is.numeric), ~ should_keep(., 0.01, 0.99)))

```


### 1.3: Create a new balanced data set where the two levels of the target variable will be equally represented; Create a bar plot of the newly created target variable. Why is this step necessary?
```{r}
loan_sample_balanced <- ovun.sample(Status ~ ., data=loan_sample_truncated, method = "under")
loan_sample_under <- data.frame(loan_sample_balanced[["data"]])

# Plot the balance
ggplot(loan_sample_under, aes(x = Status, fill = Status, group = Status)) +
  geom_bar() +
  ylab("Count") +
  xlab("Status of the loan") +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal() +
  ggtitle("New balanced dataset")

```
Balancing a dataset is important for training classification models because it prevents the model from being biased towards the majority class and potentially ignoring the minority class. This is particularly true for datasets where the outcome class of interest (e.g., default on a loan) is much less common than the non-interest class (e.g., non-default). Balancing helps to improve the generalization of the model and its performance on unseen data, especially for the minority class.

### 1.4: Investigating the distribution of the numeric features per the two levels of our target feature
(i.e. default vs non-default). Discuss the visualizations. Which variables seem to be relevant in predicting the target feature?
```{r}
# Define columns to exclude (these are column with characters)
exclude_columns <- c(3, 4, 6, 7, 14)

# Loop through columns, excluding the specified ones
for (i in setdiff(1:ncol(loan_sample_under), exclude_columns)) {
  # Only plot numeric columns
  if (is.numeric(loan_sample_under[[i]])) {
    print(ggplot(loan_sample_under, aes_string(y = names(loan_sample_under)[i], color = "Status")) +
            geom_boxplot() +
            ylab(names(loan_sample_under[i])) +
            theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(),
                  axis.ticks.x = element_blank()))
  }
}
```
Hier noch text schreiben!


### 1.5: Brotuto algorithm
In the next step, we run the Boruta algorithm.The Boruta algorithm provides a more objective method for determining the importance of features as it is based on repeated, random comparisons rather than human judgment.
```{r, echo=FALSE}
loan_sample_under$Status <- as.factor(loan_sample_under$Status)
boruta_output <- Boruta(Status~., data = loan_sample_under, doTrace=2)

# Print of significant output
boruta_signif <- getSelectedAttributes(boruta_output, withTentative = TRUE)
print(boruta_signif)

# Visualisation of the result
plot(boruta_output, cex.axis=.7, las=2, xlab="", main="Variable Importance") 
```
Hier weiter machen Abishan!!!

Now, we can examine multicollinearity, which occurs when one predictor variable in a multiple regression model can be linearly predicted from the others with a high degree of accuracy. This situation can result in skewed or misleading coefficient estimates and conclusions.

### 1.6: Visualize the correlations that emerge between the numerical features. Discuss the results. Which variables are highly correlated? Decide whether you keep all variables.
```{r}
correlations = cor(loan_sample_under[-c(3,4,6,7,14,17)])
corrplot(correlations) 
```

We can also test for the significance of the correlation. The cor_pmat function allow us to visualize the correlations explicitly marking the insignificant correlations. 

```{r}
p_value_mat <- cor_pmat(loan_sample_under[,-c(3,4,6,7,14,17)])
ggcorrplot(correlations, type = "lower", p.mat = p_value_mat) 
```

Strong Correlations: Variables with high absolute values of correlation (close to 1 or -1) are considered strongly correlated. These could indicate a redundant or derived relationship where one variable can be predicted from the other. Moderate to Weak Correlations: Values that are closer to 0 indicate a weaker relationship. Looking at the correlation plots and the output from the Boruta algorithm, we would keep all variables. 

### 1.7: Use a bar plot visualization to investigate the associations between the categorical variables and the target feature.
```{r}
# Generate a bar plot for each categorical variable
categorical_vars <- c("home_ownership", "verification_status", "purpose", "addr_state", "application_type")
# Loop over categorical variables and plot using aes() and without aes_string()
for (cat_var in categorical_vars) {
  # Check if the column exists to avoid errors
  if (!cat_var %in% names(loan_sample_under)) {
    message(paste("Skipping", cat_var, "as it is not found in the dataset."))
    next
  }
  
  # Create the plot
  plot <- loan_sample_under %>%
    group_by(.data[[cat_var]], Status) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    ggplot(aes(x = .data[[cat_var]], y = Count, fill = as.factor(Status))) +
    geom_bar(stat = "identity", position = position_dodge()) +
    labs(title = paste("Bar plot of", cat_var, "by Status"), x = cat_var, y = "Count") +
    scale_fill_discrete(name = "Status") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) # Rotate x labels for readability
   # Print the plot
  print(plot)
}

```
Hier Text schreiben!



### 1.7: Plot an interactive scatter plot of the association between the loan amount requested and the annual income of the borrower. Discuss the plot. What can you tell about the association?
```{r}
library(plotly)

# Assuming your data is in a dataframe called loan_sample and
# the relevant columns are named loan_amnt and annual_inc
plot_ly(data = loan_sample_under, x = ~loan_amnt, y = ~annual_inc, 
        type = 'scatter', mode = 'markers', 
        marker = list(size = 10, opacity = 0.5)) %>%
  layout(title = 'Association between Loan Amount and Annual Income',
         xaxis = list(title = 'Loan Amount Requested'),
         yaxis = list(title = 'Annual Income of Borrower'))


```

The areas of high density indicate common combinations of income and loan amounts, which could suggest standard loan products or typical borrower profiles. A wide range of incomes with a relatively narrow range of loan amounts might suggest that the loan amount is less sensitive to income past a certain threshold.




## Excercise 2 Train and test a logistic classifier.
Hier Text schreiben !!!
### 2.1: Dividing the sample into training and testing set
```{r}
# Split the data into training (70%) and testing (30%) sets
splitIndex <- createDataPartition(loan_sample_under$Status, p = 0.7, list = FALSE)
training_set <- loan_sample_under[splitIndex,]
testing_set <- loan_sample_under[-splitIndex,]
```

Hier Text schreiben!


```{r}
PercTable(loan_sample_under$Status)
PercTable(training_set$Status)
PercTable(testing_set$Status)
```

### 2.2:  Train the classifier and report the coefficients obtained and interpret the results. 
In the next step, we train the logit model. In terms of our inputs i.e. our Xs, we use all variables included in the data_new_under apart from the status, which is our Y. How would you interpret the results printed from the summary fit1? 
```{r, echo=FALSE}
fit1 <- glm(Status ~ ., data=training_set,family=binomial())
summary(fit1)
```

We can print out only the significant variables with p-value lower than 0.05. We notice that 9 variables are found statistically significant. 
```{r, echo=FALSE}
significant.variables <- summary(fit1)$coeff[-1,4] < 0.05
names(significant.variables)[significant.variables == TRUE]
```

### 2.3: Plot the ROC and the Precision/Recall Curve and interpret the results.
Next, we aim to evaluate the predictive performance of our model. To do so, we will plot the ROC curve. 
```{r, echo=FALSE}
testing_set$fit1_score <- predict(fit1,type='response',testing_set)
fit1_pred <- prediction(testing_set$fit1_score, testing_set$Status)
fit1_roc <- performance(fit1_pred, "tpr", "fpr")
plot(fit1_roc, lwd=1, colorize = TRUE, main = "Fit1: Logit - ROC Curve")
lines(x=c(0, 1), y=c(0, 1), col="black", lwd=1, lty=3)
```
In the next step, we visualize the Precision/Recall Curve. This curve summarizes the trade-off between the true positive rate and the positive predictive value for a predictive model using different probability thresholds.
```{r}
fit1_precision <- performance(fit1_pred, measure = "prec", x.measure = "rec")
plot(fit1_precision, main="Fit1: Logit - Precision vs Recall")
```

### 2.4: Produce the confusion matrix and interpret the results.
```{r}
# Extract the confusion matrix 
cm <- confusionMatrix(as.factor(round(testing_set$fit1_score)), testing_set$Status)
print(cm)
```

### 2.5 Report the AUC values and the overall accuracy and interpret the results.
```{r}
# AUC
fit1_auc <- performance(fit1_pred, measure = "auc")

# Overall accuracy
accuracy <- sum(diag(cm$table)) / sum(cm$table)

# Print of the values
cat("AUC: ", fit1_auc@y.values[[1]]*100, "\nOverall Accuracy: ", accuracy)
```

# Excercise 3
Thinking about the pre-processing steps that you carried out before training the logistic classifier:
### 3.1: Can you think of a way to improve the predictive performance of your data?


### 3.2: What can you do differently? (hint: Feel free to be creative and discuss any additional step in data collection and/or data pre-processing that you might try so to improve the results)



