---
title: "Credit Scoring SBD2"
author: "Abishan Arumugavel, Vladyslav Gorbunov, Gilles Nikles, Josua Reich"
date: "2023-10-10"
output:
  html_document:
    toc: yes
    toc_depth: 3
---

In the rapidly evolving landscape of financial technology, credit scoring remains a cornerstone in determining the creditworthiness of applicants. This paper delves into the realm of predictive modeling, using a dataset provided by our professors, enriched with comprehensive credit scoring information. The overarching objective of our study is to train a model that efficiently and accurately determines the eligibility of individuals for credit approval.

The task set forth by our professors involves a comprehensive journey through four key exercises. The first exercise is centered around a thorough analysis of the dataset. Here, we delve into understanding the underlying structures, identifying critical variables, and most importantly, balancing the dataset to ensure a fair representation of diverse credit scenarios.

Subsequently, in the second exercise, we focus on training and testing a logistic classifier. This step is crucial in establishing a baseline model from which further improvements can be measured.

The third exercise involves enhancing the predictive performance of the model. This stage is particularly challenging and significant, as it entails fine-tuning the model to ensure it captures the nuances of credit scoring with greater accuracy and efficiency.

Finally, the fourth exercise invites us to step into the practical world. Here, we explore the various challenges a company may face if they were to implement our model in a real-world scenario. This exercise not only grounds our theoretical work in reality but also provides valuable insights into the practical implications and considerations in deploying machine learning models in the credit industry.

This paper aims to not only present a robust model for credit scoring but also to contribute to the broader understanding of how machine learning can be effectively utilized in financial decision-making processes.


## Load packages and data

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Set seed for reproducibility
set.seed(7)

libraries = c("readr", "tidyverse", "ggplot2", "dplyr", "reshape2", "plotly", "caret", "DescTools", "pROC", "ROCR", "ROSE", "Boruta", "RColorBrewer", "ggcorrplot", "PerformanceAnalytics", "corrr", "networkD3", "reshape", "knitr", "dlookr", "corrplot")

lapply(libraries, function(x) if (!(x %in% installed.packages())) {
  install.packages(x)
})

lapply(libraries, library, quietly = TRUE, character.only = TRUE)

rm(list=ls())

# Import of dataset
loan_sample <- read_csv("loan_sample_8.csv")

# Create a copy of the original dataset
loan_sample_original <- loan_sample
```


## Excercise 1

### 1.1 Describe the data. Specifically:

#### 1.1.1: Check and report the structure of the data set.
```{r}
str(loan_sample)
```

```{r}
# Checking for NAs
any(is.na(loan_sample))
```
The result of "FALSE" from the check indicates that there are no missing values (NAs) in the "loan_sample" dataset. So the dataset is provided with full values means that we can work with this dataset without cleaning NA's.


#### 1.1.2: How many numeric and how many categorical variables are included in the data? What categorical variable has the most levels in it?
```{r}
# First we have to check whether all variables have been imported in the correct format. 
first_overview <- overview(loan_sample)
plot(first_overview)
```
It is clearly visible that the columns with the data type character still have to be converted to factors. In addition, the "Status" column is currently still a numeric data type. This must also be converted to factor, as it is a binary variable. To do further analysis this needs to be done to get further data with the same structure to use for our model and analysis.

```{r}
loan_sample <- loan_sample %>%
  mutate_if(is.character, as.factor) %>% # Convert all character columns to factors
  mutate(Status = as.factor(Status)) # Convert 'Status' column to factor

# Plot to see, if the datatypes are correct
second_overview <- overview(loan_sample)
plot(second_overview)
```
That looks right, now we can count the number of variables. As we can see, there are no anomalies in this bar chart accordingly, we should be able to proceed with these converted data.

```{r}
# Count numeric variables in 'loan_sample'
numeric_vars_count <- sum(sapply(loan_sample, is.numeric))

# Count categorical (factor) variables in 'loan_sample'
categorical_vars_count <- sum(sapply(loan_sample, is.factor))

# Print counts of numeric and categorical variables
cat("There are", numeric_vars_count, "numeric variables and", categorical_vars_count, "categorical variables in the dataset.")

```

```{r}
categorical_levels <- sapply(loan_sample, function(x) if(is.factor(x)) length(unique(x)) else NA)

# Find the name of the categorical variable with the most levels
cat_var_most_levels <- names(which.max(categorical_levels))

# Find the number of levels for this variable
levels_count <- max(categorical_levels, na.rm = TRUE)

# Print the variable name and the number of levels
cat("The categorical variable with the most levels in the dataset is:", cat_var_most_levels, "with", levels_count, "levels.")
```

#### 1.1.3: Summarize the variables. Discuss the summary statistics obtained.
```{r}
# Categorial Label with the most Levels
summary(loan_sample)
```
Our dataset contains information from 40,000 loans, giving us a detailed look into how people handle their finances. On average, folks are requesting loans around $11,687, but it's interesting to note that the range is pretty wide, going from as little as $1,000 to as much as $40,000. This tells us that people have different needs when it comes to borrowing money.

Now, when it comes to interest rates, the average is about 12.62%, but it's quite a spread. Some lucky ones are scoring rates as low as 5.31%, while others are dealing with rates as high as 27.49%. It's a reminder that what you end up with can vary quite a bit.

On the income side of things, the average yearly income for loan applicants is $63,400. But, as expected, there's a range here too. Some folks are pulling in more, and some are pulling in less. This is just a snapshot of the diversity in people's financial situations.

We also took a look at the debt-to-income ratio (DTI), which gives us an idea of how much of a person's income is tied up in paying off debt. On average, it's sitting at 18.22%. It's a useful measure for understanding how comfortably people can manage their debt.

Switching gears to credit lines, on average, people have around 10 open credit lines. But, if we look back over time, some have had as many as 21. This gives us insight into how people handle credit – how many cards or loans they've had in the past.

The average amount owed on these credit lines is $11,995, and people tend to use about half of their available credit. This shows that folks are using their credit but not maxing it out completely.

When it comes to interest payments, the average is around $1,818. That's extra money on top of the initial loan amount. Looking at the big picture, the total average outstanding debt across all loans is $99,100. This tells us that, collectively, there's a significant amount of money being borrowed.

Finally, the average credit limit on people's credit lines is $24,194. This is the maximum amount the bank allows them to borrow. It's a cap on their potential debt.

So, diving into these numbers not only gives us a sense of individual financial situations but also paints a broader picture of how people navigate their finances through loans.

#### 1.1.4: Check the levels of the target variable by choosing the appropriate visualization. Is the target variable balanced?
```{r}
# Plot the distribution of the target variable
ggplot(loan_sample, aes(x = Status, fill = Status)) + 
  geom_bar() +
  scale_fill_brewer(palette = "Set1") + 
  labs(title = 'Distribution of target variable (Status)', x = 'Status', y = 'Count') +
  theme_minimal()

```
The 'Status' variable in our dataset serves as a crucial indicator of credit approval outcomes. It distinctly classifies these outcomes into two levels: '0' represents a 'No,' indicating that the credit has not been approved, while '1' signifies a 'Yes,' confirming the approval of the credit.

Upon closer inspection, our dataset reveals a notable imbalance in the distribution of these outcomes. Specifically, there is a significantly higher number of instances where credits were not approved (Status '0') compared to those that were approved (Status '1'). This imbalance is a critical aspect to consider, especially in the context of machine learning model development.

In machine learning, an unbalanced dataset can introduce bias into the predictive model. In our case, the imbalance may lead the model to overemphasize the majority class (non-approved credits), potentially resulting in a classifier that tends to predict a 'No' more frequently.

To mitigate this issue, it becomes essential to address the class imbalance before training our predictive model. Balancing the dataset involves techniques such as oversampling the minority class (approved credits), undersampling the majority class (non-approved credits), or using more advanced methods like synthetic data generation. By doing so, we aim to create a more equitable representation of both outcomes in our training data.

#### 1.1.5: Check the distribution of the numeric variables in the data set (include different visual representations).
```{r}
# Histograms
loan_sample %>% 
  select_if(is.numeric) %>% 
  gather(key = "variable", value = "value") %>%
  ggplot(aes(x = value)) +
  geom_histogram(bins = 30) +
  facet_wrap(~variable, scales = 'free_x') +
  theme_minimal()
```

The histogram we created for the variable open_acc has gaps. We should examine this more closely.
```{r}
# Create boxplot of the variable total_acc
ggplot(loan_sample, aes(x = open_acc)) +
  geom_histogram(bins = 22) + # Adjust the number of bins as necessary
  labs(x = "Open Accounts", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```
Since the variable ranges from 1 to 22, using 30 bins leads to empty spaces. Adjusting the bins to match the actual value range has provided a clearer, gap-free histogram.

```{r}
# Boxplots
loan_sample %>% 
  select_if(is.numeric) %>% 
  gather(key = "variable", value = "value") %>%
  ggplot(aes(y = value)) +
  geom_boxplot() +
  facet_wrap(~variable, scales = 'free') +
  theme_minimal()
```


### 1.2: Investigating outliers with a box plot
Elaborate your view on how to proceed in dealing with the outliers and – if necessary – take appropriate action.
```{r}
# Reshape the data to long format and scale the numeric values
loan_sample_long_scaled <- loan_sample %>%
  select(where(is.numeric)) %>%
  mutate(across(everything(), scale)) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value")

# Create a boxplot with the scaled values
ggplot(loan_sample_long_scaled, aes(x = variable, y = value)) +
  geom_boxplot() +
  labs(x = "", y = "Scaled Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

The box plot effectively captures the distribution of scaled numeric variables, and the presence of outliers is evident as individual points outside the box plot. Notably, several variables exhibit outliers, indicating the potential presence of extreme values in our dataset.

To gain a deeper understanding, it is essential to contextualize these outliers. Are they genuine extreme values reflective of the population, or do they stem from errors in data collection or measurement discrepancies? This distinction is crucial in determining the appropriate course of action.

Understanding the impact of outliers on our analysis is paramount. Outliers can significantly influence statistical measures, potentially skewing measures of central tendency and affecting the overall spread of the data. For instance, they may impact the accuracy of mean values and standard deviations.

A closer look at the box plot reveals specific variables that seem to have more pronounced outliers. Exploring these outliers in the context of the variables they pertain to could reveal valuable insights and guide subsequent steps in the analysis.

Various statistical techniques, such as calculating z-scores or leveraging the interquartile range (IQR), can systematically identify outliers. Implementing these techniques allows for a more rigorous and objective assessment of outlier presence.

When deciding how to address outliers, removal or correction is a common approach. However, alternative strategies exist, including transforming the data, winsorizing (capping extreme values), or stratifying analyses based on the presence of outliers. Each strategy comes with its considerations and potential implications for the overall analysis.

In summary, recognizing and addressing outliers is a nuanced process that requires careful consideration of their nature, impact, and appropriate handling strategies to ensure the integrity of our analysis.

```{r}
# Diagnosing outliers and selecting variables with more than 1% outliers
variables_with_high_outlier_ratio <- loan_sample %>%
  diagnose_outlier() %>%
  filter(outliers_ratio > 1) %>%
  pull(variables)

# Plotting the outliers for these variables
loan_sample %>%
  plot_outlier(one_of(variables_with_high_outlier_ratio))

```
As we worked on refining our model, we initially thought removing more outliers would make it better, so we decided to keep 95% of our data and discard the top 5% as outliers. Surprisingly, this move didn't improve the model; in fact, it made it less precise.

Realizing that less might be more in this case, we changed our approach. Instead of removing 5%, we opted for a more cautious strategy, cutting out only 1% of outliers. This way, we're holding onto 99% of our data, hoping to strike a balance between cleaning up noisy data and keeping enough information for the model to learn effectively.

This back-and-forth shows that finding the right balance in handling outliers is a bit of a puzzle, and we're trying to crack it to make our model as accurate and reliable as possible.

```{r}
# Function for adjusting the values to the quantile limits
cap_values_at_quantiles <- function(x) {
    quantiles <- quantile(x, c(0.01, 0.99), na.rm = TRUE)
    x <- ifelse(x < quantiles[1], quantiles[1], x)
    x <- ifelse(x > quantiles[2], quantiles[2], x)
    x
}

loan_sample_truncated <- loan_sample %>%
  mutate(across(where(is.numeric), cap_values_at_quantiles))


```

### 1.3: Create a new balanced data set where the two levels of the target variable will be equally represented; Create a bar plot of the newly created target variable. Why is this step necessary?
```{r}
loan_sample_balanced <- ovun.sample(Status ~ ., data=loan_sample_truncated, method = "under")
loan_sample_under <- data.frame(loan_sample_balanced[["data"]])

# Plot the balance
ggplot(loan_sample_under, aes(x = Status, fill = Status, group = Status)) +
  geom_bar() +
  ylab("Count") +
  xlab("Status of the loan") +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal() +
  ggtitle("New balanced dataset")

```
Balancing the dataset is key for training models, especially when dealing with imbalanced classes like predicting loan default. This ensures a fair representation of both outcomes, preventing the model from favoring the more common class. By striking this balance, we aim to improve the model's accuracy and fairness in predicting both common and less frequent events, contributing to a more reliable and equitable performance.

### 1.4: Investigating the distribution of the numeric features per the two levels of our target feature
(i.e. default vs non-default). Discuss the visualizations. Which variables seem to be relevant in predicting the target feature?
```{r}
# Define columns to exclude (these are column with characters)
exclude_columns <- c(3, 4, 6, 7, 14)

# Loop through columns, excluding the specified ones
for (i in setdiff(1:ncol(loan_sample_under), exclude_columns)) {
  # Only plot numeric columns
  if (is.numeric(loan_sample_under[[i]])) {
    print(ggplot(loan_sample_under, aes_string(y = names(loan_sample_under)[i], color = "Status")) +
            geom_boxplot() +
            ylab(names(loan_sample_under[i])) +
            theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(),
                  axis.ticks.x = element_blank()))
  }
}
```

While looking at the boxplots, it's clear that some variables don't show much difference between the 'Status' '0' and '1' categories. Notably, interest rate, annual income, total revenue, and DTI stand out with significant differences between the two statuses. However, manually creating each boxplot can be time-consuming, and interpreting them might lack a systematic approach.

To tackle this, we decided on a more comprehensive method by combining manual boxplot analysis with insights from the Boruta algorithm. This hybrid approach blends both manual examination and algorithmic assistance, aiming for a nuanced understanding of the data and highlighting potential correlations. By doing this, we aim for a well-rounded outcome, drawing on the strengths of both manual and automated analyses to gain a more robust understanding of the dataset's relationships.

This hybrid model allows for a more informed interpretation, ensuring that the observed deviations in specific variables are thoroughly considered within the broader dataset context. It represents a holistic and balanced approach, bringing together human expertise and algorithmic rigor to deepen our understanding of the correlation patterns in our data.

### 1.5: Use a bar plot visualization to investigate the associations between the categorical variables and the target feature.
```{r}
# Generate a bar plot for each categorical variable
categorical_vars <- c("grade", "home_ownership", "verification_status", "purpose", "application_type")
# Loop over categorical variables and plot
for (cat_var in categorical_vars) {
  # Check if the column exists to avoid errors
  if (!cat_var %in% names(loan_sample_under)) {
    message(paste("Skipping", cat_var, "as it is not found in the dataset."))
    next
  }
  
  # Create the plot
  plot <- loan_sample_under %>%
    group_by(.data[[cat_var]], Status) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    ggplot(aes(x = .data[[cat_var]], y = Count, fill = as.factor(Status))) +
    geom_bar(stat = "identity", position = position_dodge()) +
    labs(title = paste("Bar plot of", cat_var, "by Status"), x = cat_var, y = "Count") +
    scale_fill_discrete(name = "Status") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) # Rotate x labels for readability
   # Print the plot
  print(plot)
}

```
For this analysis, we made use of a loop to keep the code tidy. A noteworthy observation is that in stage D, the ratio of '1' to '0' is nearly twice as high, leading to a noticeable difference. On the flip side, in stage A, we see the opposite trend. Moving on to the Home Ownership plot, it becomes apparent that individuals who rent a house or apartment have higher chances of being creditworthy compared to those with a mortgage, where the odds are notably lower. Interestingly, no significant influence is observed for individuals who already own property.

In the subsequent graph, the significance of having a verified source of income on creditworthiness is emphasized. Moreover, it's worth noting whether only the source is verified or if the exact data is also confirmed. This aligns logically with the idea that such verification substantially reduces the bank's risk, thereby significantly enhancing data security.

Debt consolidation stands out with a high occurrence. We speculate that the data might be from the USA or other countries, as we believe such a trend might be more of an exclusion criterion in Switzerland. Nevertheless, debt consolidation can also make economic sense, allowing individuals to pay lower interest rates on existing loans. The criterion of owning a credit card is remarkably high, indicating their common use. However, it doesn't seem to have a significant impact on the approval of credit applications.

The Application Type is intriguing, revealing that a lot more people opt for an individual loan, while very few consider a joint application. Surprisingly, though, it doesn't play a substantial role in influencing credit approval.


### 1.6: Boruta algorithm
In the next step, we run the Boruta algorithm.The Boruta algorithm provides a more objective method for determining the importance of features as it is based on repeated, random comparisons rather than human judgment.
```{r, echo=FALSE}
# Set seed for reproducibility
set.seed(7)

# Boruta algorithm
loan_sample_under$Status <- as.factor(loan_sample_under$Status)
boruta_output <- Boruta(Status~., data = loan_sample_under, doTrace=2)

# Print of significant output
boruta_signif <- getSelectedAttributes(boruta_output, withTentative = TRUE)
print(boruta_signif)

# Visualisation of the result
plot(boruta_output, cex.axis=.7, las=2, xlab="", main="Variable Importance") 
```
With the Boruta method providing valuable insights, the next step in our analysis involves a closer examination of multicollinearity. Multicollinearity arises when one predictor variable in a multiple regression model can be accurately predicted from the others. This phenomenon can lead to skewed or misleading coefficient estimates and draw potentially erroneous conclusions.

In essence, the presence of multicollinearity introduces a level of redundancy among predictor variables, making it challenging to isolate their individual effects on the response variable. When high correlations exist between predictors, it becomes difficult for the regression model to distinguish the unique contributions of each variable, potentially compromising the accuracy and reliability of the model.

Identifying and addressing multicollinearity is critical for refining the integrity of our regression analysis. It allows us to disentangle the interdependencies between predictor variables and ensures that each variable's impact on the response variable is accurately reflected. By navigating the complexities of multicollinearity, we aim to enhance the robustness of our regression model, providing more accurate and trustworthy insights into the relationships between predictors and the target variable.


### 1.7: Visualize the correlations that emerge between the numerical features. Discuss the results. Which variables are highly correlated? Decide whether you keep all variables.
```{r}
correlations = cor(loan_sample_under[-c(3,4,6,7,14,17)])
corrplot(correlations) 
```

In addition to exploring correlations, we delve deeper into their statistical significance. Utilizing the cor_pmat function, we gain the ability to explicitly assess the significance of each correlation, with a distinct focus on highlighting the insignificant ones.

This method goes beyond merely identifying correlations; it allows us to scrutinize the strength and reliability of each correlation coefficient. By explicitly marking correlations that are deemed statistically insignificant, we enhance our ability to distinguish between robust relationships and those that may occur by chance.

The cor_pmat function becomes a valuable tool in this context, offering a visual representation that guides us in pinpointing correlations that warrant closer scrutiny. This nuanced approach not only emphasizes the presence of correlations but also refines our understanding by discerning the statistical significance associated with each, providing a more comprehensive evaluation of the interplay between variables.

```{r}
p_value_mat <- cor_pmat(loan_sample_under[,-c(3,4,6,7,14,17)])
ggcorrplot(correlations, type = "lower", p.mat = p_value_mat) 
```

When we look at how variables in our dataset relate to each other, those with a high correlation, close to 1 or -1, are seen as strongly linked. It suggests that knowing one variable might pretty much tell us about the other, hinting at a kind of redundant or closely connected relationship.

Conversely, when the correlation is closer to 0, it means the relationship is weaker. It could be moderate or just a faint connection between variables. This indicates that understanding one variable might not necessarily give us a good prediction for another.

In our analysis, we checked correlation plots and got insights from the Boruta algorithm. Interestingly, despite seeing varying strengths in correlations, we've decided to keep all the variables. The reason behind this choice is that even if the relationships are not super strong, each variable brings in unique and valuable information.

The idea here is to appreciate the mix of both strong and not-so-strong connections between variables. Keeping all the variables allows us to have a more complete understanding of the dataset, considering the nuances and diverse information each variable brings to the table.



### 1.8: Plot an interactive scatter plot of the association between the loan amount requested and the annual income of the borrower. Discuss the plot. What can you tell about the association?
```{r}
library(plotly)

# Assuming your data is in a dataframe called loan_sample and
# the relevant columns are named loan_amnt and annual_inc
plot_ly(data = loan_sample_under, x = ~loan_amnt, y = ~annual_inc, 
        type = 'scatter', mode = 'markers', 
        marker = list(size = 10, opacity = 0.5)) %>%
  layout(title = 'Association between Loan Amount and Annual Income',
         xaxis = list(title = 'Loan Amount Requested'),
         yaxis = list(title = 'Annual Income of Borrower'))
```

As we examine the density plot, the regions with high density unveil common combinations of income and loan amounts, offering insights into potential standard loan products or characteristic borrower profiles. The clustering of data points in these areas indicates prevalent patterns that could be indicative of well-established loan products catering to specific income brackets or borrower demographics.

Up to a salary of 20k, people tend to apply for a maximum loan of 10k. With a salary of around 40k, the requested loan amount increases to about 20k. Surprisingly, at a salary of 60k, the loan application amount is around 25k. This suggests that the increase in loan amount is not directly proportional to the income; rather, it seems to follow a diminishing trend. Once again, the exception here confirms the rule, showing that higher loans are sought with lower incomes and the other way around.


## Excercise 2 Train and test a logistic classifier.

We divided the data into a 30/70 ratio, allocating 70% of the data for training purposes and reserving the remaining 30% for testing. This approach ensures that our model is trained on a substantial portion of the dataset, allowing it to learn patterns and relationships. The logistic classifier serves as our chosen model, given our specific goal of evaluating whether a loan is granted or not, as indicated by the 'Status' column.

The training phase involves exposing the model to the majority of the data, enabling it to grasp the underlying patterns and relationships. Subsequently, we assess its performance on the reserved testing set, which represents new, unseen data. This evaluation provides valuable insights into how well the model generalizes to real-world scenarios.

By leveraging this 30/70 split and utilizing a logistic classifier, our aim is to develop a robust and accurate model capable of making reliable predictions regarding loan approval based on the provided input features. This process aligns with best practices in machine learning, striking a balance between training and evaluation to ensure the model's effectiveness in real-world applications.


### 2.1: Dividing the sample into training and testing set
```{r}
# Set seed for reproducibility
set.seed(7)

# Split the data into training (70%) and testing (30%) sets
splitIndex <- createDataPartition(loan_sample_under$Status, p = 0.7, list = FALSE)
training_set <- loan_sample_under[splitIndex,]
testing_set <- loan_sample_under[-splitIndex,]
```



```{r}
PercTable(loan_sample_under$Status)
PercTable(training_set$Status)
PercTable(testing_set$Status)
```

### 2.2:  Train the classifier and report the coefficients obtained and interpret the results. 
In the next step, we train the logit model. In terms of our inputs i.e. our Xs, we use all variables included in the data_new_under apart from the status, which is our Y. How would you interpret the results printed from the summary fit1? 


```{r, echo=FALSE}
fit1 <- glm(Status ~ ., data=training_set,family=binomial())
summary(fit1)
```

We can print out only the significant variables with p-value lower than 0.05. We notice that 9 variables are found statistically significant. 
```{r, echo=FALSE}
significant.variables <- summary(fit1)$coeff[-1,4] < 0.05
names(significant.variables)[significant.variables == TRUE]
```

### 2.3: Plot the ROC and the Precision/Recall Curve and interpret the results.
Next, we aim to evaluate the predictive performance of our model. To do so, we will plot the ROC curve. 
```{r}
testing_set$fit1_score <- predict(fit1,type='response',testing_set)
fit1_pred <- prediction(testing_set$fit1_score, testing_set$Status)
fit1_roc <- performance(fit1_pred, "tpr", "fpr")
plot(fit1_roc, lwd=1, colorize = TRUE, main = "Fit1: Logit - ROC Curve")
lines(x=c(0, 1), y=c(0, 1), col="black", lwd=1, lty=3)
```
In the subsequent step of our analysis, we delve into the intricacies of our model by visualizing the Precision/Recall Curve. This curve serves as a comprehensive illustration of the delicate balance between the true positive rate and the positive predictive value across various probability thresholds.

As we navigate through different probability thresholds, the Precision/Recall Curve provides a nuanced perspective on the model's performance. It vividly captures the trade-offs inherent in our predictive model, offering valuable insights into how adjusting the probability threshold impacts both precision and recall.

Precision, representing the accuracy of positive predictions, and recall, measuring the model's ability to capture all actual positive instances, are pivotal metrics in evaluating classifier performance. By exploring this curve, we gain a deeper understanding of the model's behavior across a spectrum of probability thresholds, enabling us to make informed decisions about the optimal threshold for our specific use case.

This visual representation not only aids in model evaluation but also guides us in fine-tuning our predictive approach for achieving the desired balance between precision and recall, aligning with the specific objectives and requirements of our analysis.

```{r}
fit1_precision <- performance(fit1_pred, measure = "prec", x.measure = "rec")
plot(fit1_precision, main="Fit1: Logit - Precision vs Recall")
```
Hier noch genau erklären und herausfinden warum es ein Sprung macht.
Erklärung von Chat GPT:
Die Kurve kann Unregelmäßigkeiten in der Verteilung der Klassifizierungswahrscheinlichkeiten widerspiegeln. Ein kleiner Satz von Beispielen, die sehr sicher als positiv klassifiziert werden, gefolgt von einer größeren Gruppe von Beispielen mit weniger Sicherheit, könnte zu einem solchen Sprung führen.

### 2.4: Produce the confusion matrix and interpret the results.
```{r}
# Extract the confusion matrix 
cm <- confusionMatrix(as.factor(round(testing_set$fit1_score)), testing_set$Status)
print(cm)
```

### 2.5 Report the AUC values and the overall accuracy and interpret the results.
```{r}
# AUC
fit1_auc <- performance(fit1_pred, measure = "auc")

# Overall accuracy
accuracy <- sum(diag(cm$table)) / sum(cm$table)

# Print of the values
cat("AUC: ", fit1_auc@y.values[[1]]*100, "\nOverall Accuracy: ", accuracy)
```

## Excercise 3
Thinking about the pre-processing steps that you carried out before training the logistic classifier:
Can you think of a way to improve the predictive performance of your data?

### 3.1.1: Training the logistic classifier without any preprocessing and feature selection stepps
```{r}
# Set seed for reproducibility
set.seed(7)

# Splitting the data into testing and training data
splitIndex2 <- createDataPartition(loan_sample$Status, p = 0.7, list = FALSE)
training_set2 <- loan_sample[splitIndex2,]
testing_set2 <- loan_sample[-splitIndex2,]

# Percentage table of Status with out preprocessing
PercTable(loan_sample$Status)
PercTable(training_set2$Status)
PercTable(testing_set2$Status)

# Fitting the model
fit2 <- glm(Status ~ ., data=training_set2,family=binomial())
summary(fit2)

# Print out only the significant variables with p-value lower than 0.05.
significant.variables2 <- summary(fit2)$coeff[-1,4] < 0.05
names(significant.variables2)[significant.variables2 == TRUE]

testing_set2$fit2_score <- predict(fit2,type='response',testing_set2)
fit2_pred <- prediction(testing_set2$fit2_score, testing_set2$Status)
fit2_roc <- performance(fit2_pred, "tpr", "fpr")
plot(fit2_roc, lwd=1, colorize = TRUE, main = "Fit2: Logit - ROC Curve")
lines(x=c(0, 1), y=c(0, 1), col="black", lwd=1, lty=3)

fit2_precision <- performance(fit2_pred, measure = "prec", x.measure = "rec")
plot(fit2_precision, main="Fit2: Logit - Precision vs Recall")

# Extract the confusion matrix 
cm2 <- confusionMatrix(as.factor(round(testing_set2$fit2_score)), testing_set2$Status)
print(cm2)

# AUC
fit2_auc <- performance(fit2_pred, measure = "auc")

# Overall accuracy
accuracy2 <- sum(diag(cm2$table)) / sum(cm2$table)

# Print of the values
cat("AUC: ", fit2_auc@y.values[[1]]*100, "\nOverall Accuracy: ", accuracy2)
```

### 3.1.2: Training the logistic classifier without the collumn application type
```{r}
# Set seed for reproducibility
set.seed(7)

# Deleting column application_type
loan_sample_under_new <- loan_sample_under[-14]

# Splitting the data into testing and training data
splitIndex3 <- createDataPartition(loan_sample_under_new$Status, p = 0.7, list = FALSE)
training_set3 <- loan_sample_under_new[splitIndex3,]
testing_set3 <- loan_sample_under_new[-splitIndex3,]

# Percentage table of Status with out preprocessing
PercTable(loan_sample_under_new$Status)
PercTable(training_set3$Status)
PercTable(testing_set3$Status)

# Fitting the model
fit3 <- glm(Status ~ ., data=training_set3,family=binomial())
summary(fit3)

# Print out only the significant variables with p-value lower than 0.05.
significant.variables3 <- summary(fit3)$coeff[-1,4] < 0.05
names(significant.variables3)[significant.variables3 == TRUE]

testing_set3$fit3_score <- predict(fit3,type='response',testing_set3)
fit3_pred <- prediction(testing_set3$fit3_score, testing_set3$Status)
fit3_roc <- performance(fit3_pred, "tpr", "fpr")
plot(fit3_roc, lwd=1, colorize = TRUE, main = "Fit3: Logit - ROC Curve")
lines(x=c(0, 1), y=c(0, 1), col="black", lwd=1, lty=3)

fit3_precision <- performance(fit3_pred, measure = "prec", x.measure = "rec")
plot(fit3_precision, main="Fit3: Logit - Precision vs Recall")

# Extract the confusion matrix 
cm3 <- confusionMatrix(as.factor(round(testing_set3$fit3_score)), testing_set3$Status)
print(cm3)

# AUC
fit3_auc <- performance(fit3_pred, measure = "auc")

# Overall accuracy
accuracy3 <- sum(diag(cm3$table)) / sum(cm3$table)

# Print of the values
cat("AUC: ", fit3_auc@y.values[[1]]*100, "\nOverall Accuracy: ", accuracy3)
```


### 3.2: What can you do differently? (hint: Feel free to be creative and discuss any additional step in data collection and/or data pre-processing that you might try so to improve the results)


# Excercise 4
Finally, thinking about putting your model into action and basing credit decisions on the prediction that it generates:
• What kind of challenges may a company face if it would use your model in their daily business, in particular in regard to ethical challenges and moral obligations companies have? Please refer to the „common ethical issues in the context the creation of value from data” (see slides week 11) in your answer.
• Can you think of a way how companies can overcome or at least mitigate the issues that you described above?
